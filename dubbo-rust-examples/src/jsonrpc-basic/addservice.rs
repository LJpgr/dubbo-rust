/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// this file should be auto generated by crate dubbo-rust-build (WIP) , now it is hand-write : )

#![allow(dead_code)]

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::{future::Future, pin::Pin};

pub type StdError = Box<(dyn std::error::Error + Send + Sync + 'static)>;
pub type BoxFuture<R, E> = Pin<Box<(dyn Future<Output = Result<R, E>> + Send + 'static)>>;

#[derive(Debug, Deserialize, Serialize)]
pub struct AddReq {
    pub numbers: Vec<i32>,
}

pub type AddResp = i32;

#[async_trait]
pub trait AddService {
    async fn add(&mut self, req: AddReq) -> Result<AddResp, StdError>;
}

pub mod add_service {
    use std::task::Poll;

    use dubbo_rust_protocol::{
        jsonrpc::{Request, Response},
        NamedService,
    };

    use super::{AddReq, AddService, BoxFuture, StdError};

    #[derive(Clone)]
    pub struct AddServer<T: AddService + Clone> {
        inner: T,
    }

    impl<T: AddService + Clone> AddServer<T> {
        pub fn new(service: T) -> Self {
            Self { inner: service }
        }
    }

    impl<T: AddService + Clone> NamedService for AddServer<T> {
        const SERVICE_NAME: &'static str = "AddService";
    }

    impl<T> tower::Service<Request> for AddServer<T>
    where
        T: AddService + Clone + Send + 'static,
    {
        type Response = Response;

        type Error = StdError;

        type Future = BoxFuture<Self::Response, Self::Error>;

        fn poll_ready(
            &mut self,
            _: &mut std::task::Context<'_>,
        ) -> std::task::Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }

        fn call(&mut self, req: Request) -> Self::Future {
            let method_not_found = |req: Request| {
                Box::pin(async move {
                    let error = dubbo_rust_protocol::jsonrpc::Error {
                        code: -32601,
                        message: "Method not found".to_string(),
                    };

                    Ok(Response::from_request_error(&req, error))
                })
            };

            if req.header.method.is_none() {
                return method_not_found(req);
            }

            let mut inner_service = self.inner.clone();
            match req.header.method.as_ref().unwrap().as_str() {
                "add" => Box::pin(async move {
                    let params: AddReq = serde_json::from_value(req.params.clone())?;
                    let result = inner_service.add(params).await?;
                    Ok(Response::from_request(&req, result)?)
                }),
                _ => method_not_found(req),
            }
        }
    }
}

pub mod add_client {
    use std::net::SocketAddr;

    use super::{AddReq, AddResp, StdError};
    use dubbo_rust_protocol::jsonrpc::Request as JsonRpcRequest;
    use dubbo_rust_protocol::jsonrpc::Response as JsonRpcResponse;
    use hyper::body::HttpBody;
    use hyper::client::HttpConnector;

    pub struct AddClient {
        addr: SocketAddr,
        http_client: hyper::Client<HttpConnector>,
    }

    impl AddClient {
        pub fn new(addr: &SocketAddr) -> Result<Self, StdError> {
            let client = hyper::Client::new();
            Ok(Self {
                addr: addr.clone(),
                http_client: client,
            })
        }

        pub async fn add(&mut self, req: AddReq) -> Result<AddResp, StdError> {
            let req = JsonRpcRequest::new("add", req)?;
            let req_str = req.to_string()?;
            let http_request = hyper::Request::builder()
                .method("POST")
                .uri(format!("http://{}", self.addr.to_string()))
                .body(hyper::Body::from(req_str))
                .expect("request builder");

            let mut resp = self.http_client.request(http_request).await?;

            let body = resp.data().await;
            if body.is_none() {
                return Err("body empty".into());
            }
            let body = body.unwrap()?;
            let jsonrpc_resp = JsonRpcResponse::from_slice(&body.to_vec())?;

            Ok(jsonrpc_resp.get_body()?)
        }
    }
}
